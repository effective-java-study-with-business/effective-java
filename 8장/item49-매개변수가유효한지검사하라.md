# 아이템49. 매개변수가 유효한지 검사하라

## 메서드 매개변수 검사

- 메서드와 생성자 대부분은 입력 매개변수의 값에 제약이 있다.
- ex) 인덱스가 음수면 안됨, 객체 참조는 null이 아니여야 함
- 이런 제약들은 반드시 문서화해야 하며, 메서드 몸체가 실행되기 전에 검사되어야 한다.
- 오류를 발생한 즉시 잡지 못하면 해당 오류를 감지하기 어려워지고, 감지하더라도 오류 발생 지점을 찾기 어려워진다.

### 메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다.

### 매개변수 검사를 제대로 하지 못하면 몇 가지 문제가 발생할 수 있는데,

1. 메서드가 수행되는 중간 모호한 예외를 던지며 실패할 수 있다.
2. 메서드가 잘못된 결과를 반환할 수 있다.
3. 실패 원자성(아이템76)을 어기는 결과를 낳을 수 있다.

## 매개변수 제약 문서화

- public, protect 메서드는 매개변수 값이 잘못되었을 때 던지는 예외를 문서화 해야한다.
- @throws 자바독 태그를 사용할 수 있다.
- 매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.
- 이러한 방법으로 API 사용자가 제약을 지킬 가능성을 크게 높힐 수 있다.

### 문서화 예시

```java
/**
* (현재 값 mod m) 값을 반환한다.
* 이 메서드는 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다.
* <i>non-negative</i> BigInteger.
*
* @param  m 계수(양수여야 한다.)
* @return 현재 값 mod m
* @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
*
*/
public BigInteger mod(BigInteger m) {
    if (m.signum() <= 0)
        throw new ArithmeticException("계수(m)는 양수여야 합니다." + m);

    // 계산 로직
}
```

- 위의 메서드는 m이 null일 경우, m.signum()이 호출될 때 NullPointerException을 던진다.
- 근데? 여기 어디에도 “m이 null일 경우 NullPointerException을 던진다”라는 설명이 없다!
- 그 이유는 이 설명을 개별 메서드 수준에 일일이 적는 것이 아니라, BigInteger 라는 클래스 수준에서 기술해두었기 때문이다.
- 클래스 수준 주석은 그 클래스 모든 public 메서드에 적용되므로 각 메서드에 일일이 기술하는 것보다 훨씬 깔끔한 방법이다.

## 자바의 null 검사 기능 사용

- 자바 7에 추가된 java.util.Objects.requireNonNull 메서드는 유연하고 사용하기 편하다.
- 이를 사용하면 null 검사를 수동으로 하지 않아도 된다.
- 원하는 예외 메시지도 지정할 수 있고, 입력을 그대로 반환하므로 값을 사용하는 동시에 null 검사를 수행할 수 있다.

```java
this.strategy = Objects.requireNonNull(strategy, "예외 메세지");
```

- 참고 : Objects.requireNonNull의 첫번째 파라미터는 검사할 객체, 두번째 파라미터는 던질 예외메세지

## 자바 9의 범위 검사

자바 9부터는 범위 검사도 가능한데,

- checkFromIndexSize(배열이나 리스트 등의 자료구조를 다룰 때, 특히 서브리스트(sublist)를 추출할 때 등 범위를 지정할 때 사용)
- checkFromToIndex(FromIndex가 0보다 작지않고, ToIndex보다 크지 않으며, ToIndex는 구하고자 하는 length의 길이보다 크지 않고, length는 0보다 작지 않은지 검사)
- checkIndex(Index가 0보다 작지않고 length를 초과하지 않으며, length가 0보다 작지 않은지 검사)

등이 있다.

근데 이런 메서드들은 null 검사 메서드만큼 유연하지는 않다. 예외 메세지를 지정할 수 없고, 리스트와 배열 전용으로 설계되었고, 닫힌 범위(closed range)는 다루지 못하기 때문.

하지만 이런 제약이 없을 때는 유용할지도?!

## Private 메서드

- private 메서드라면 패키지 제작자인 우리가 메서드가 호출되는 상황을 통제할 수 있다.
- 따라서 오직 유효한 값만이 메서드에 넘겨지는 것을 보증해야 한다.

### 재귀 정렬용 private 도우미 함수

```java
private static void sort(long a[], int offset, int length) {
  assert a != null;
  assert offset >= 0 && offset <= a.length;
  assert length >= 0 && length <= a.length - offset;
  ..// 로직
}
```

여기서 핵심은 이 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다. 단언문은 일반적인 유효성 검사와 다르다. 디버깅 모드로 사용된다.

- 실패하면 AssertionError를 던진다
- 런타임에 아무런 효과도 성능 저하도 없다.(실제 배포 환경에서는 무시됨)
    - 단 java를 실행할 때 명령줄에서 -ea 혹은 –enableassertions 플래스 설정을 하면 영향을 준다.

# **유효성 검사 예외**

가끔은 유효성 검사를 하지 않아도 될 때가 있다.

- 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때
- 계산 과정에서 암묵적으로 수행될 때

예를 들어 `Collections.sort(List)` 처럼 정렬하는 메서드는 리스트 안의 객체들은 모두 상호 비교될 수 있어야 하며, 정렬 과정에서 이 비교가 이뤄진다.

만약 상호 비교될 수 없는 타입의 객체가 들어 있다면, 그 객체와 비교할 때 `ClassCastException` 을 던진다.

따라서 비교하기 앞서 리스트 안의 모든 객체가 상호 비교될 수 있는지 검사해봐야 별다른 이득이 없다.

하지만 암묵적 유효성 검사에 너무 의존했다가는 실패 원자성을 해칠 수 있으니 주의하자.

## 정리

"매개변수에 제약을 두는게 좋다"라고 해석하는게 아니고, 

메서드는 최대한 범용적으로 설계하여 메서드가 건네 받은 값으로 무언가 제대로 된 일을 할 수 있다면

매개변수 제약은 적을 수록 좋다라는 뜻으로 이해하자.
