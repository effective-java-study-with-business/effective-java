# 아이템 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라

정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다

## 좋은 프로그램을 만드는 방법

### 프로세스 수를 고려하여 적절한 스레드로 유지
1. 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 한다.
-> 스케줄러가 고민할 거리가 줄어든다.
2. 실행준비가 된 스레드들은 맡은 작업을 완료할 때까지 계속 실행되도록 만든다.
-> 스케줄링 정책이 아주 상이한 시스템에서도 동작이 크게 달라지지 않는다.

### 실행 가능한 스레드 수를 적게 유지한다.
1. 다음 일거리가 생길 때까지 대기하도록한다. 단, 스레드는 당장 처리해야 할 작업이 없다면 실행해서는 안 된다.
2. 작업이 너무 짧으면 작업을 분배하는 부담이 오히려 성능을 떨어뜨릴 수 있다.

### Busy Waiting 상태가 되면 안된다.

```java
public void await() {
	while (true) {    // 계속해서 조건을 충족하는지 검사
    	synchornized(this) {
        	if (count == 0) return;
        }
    }
}
```
공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사해서는 안 된다는 뜻이다.
busy waiting은 스레드 스케줄러의 변덕에 취약할 뿐아니라, 프로세서에 큰 부담을 주어 다른 유용한 작업이 실행 될 기회를 박탈한다.


## CPU시간을 충분히 얻지 못하는 프로그램이라도 Thread.yield 사용 금지

```java
public void run() {
    while(true) {
        if(work) {
            //Thread 작업 내용
        } else {
            Thread.yield();
        }
    }
}
```
Thread.yield  : JVM의 Thread Scheduler에게 현재 스레드의 우선 순위를 낮춰도 된다는 힌트를 보내는 메서드

말그대로 힌트만 주는 메서드이기 때문에 확실히 우선순위가 변동된다는 보장도 없고, 테스트할 수단도 없으니
차라리 어플리케이션 구조를 바꿔 동시에 실행 가능한 스레드 수가 적어지도록 조치하자

## 요약
1. 프로그램 동작을 스레드 스케줄러에 기대지 말자.
2. Thread.yield와 스레드 우선순위에 의존해서도 안된다. 힌트일 뿐
