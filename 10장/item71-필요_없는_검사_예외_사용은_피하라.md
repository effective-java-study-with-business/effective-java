# 아이템 71. 필요 없는 검사 예외 사용은 피하라

결과를 코드로 반환하거나 비검사 예외를 던지는 것과 달리, 검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게끔 해준다.
하지만, 과하게 사용시 오히려 쓰기 불편하고, 검사예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없다.

검사 예외와 비검사 예외 중 어느 것을 선택해야할지는 프로그래머가 예외를 어떻게 다룰지 생각해보면 알 수 있다.

## 비검사 예외

흔한 예외처리
```java
try {
  // ...
} catch (TheCheckedException e) {
  throw new AssertionError(); // 일어날 수 없다!
}
try {
  // ...
} catch (TheCheckedException e) {
  e.printStackTrace(); // 이런, 우리가 졌다!
  System.exit(1);
}
```
예외 처리 시 다음과 같은 방법보다 더 나은 방법이 없다면 비검사 예외를 선택해야한다.

### 검사 예외를 회피하는 방법 1: 옵셔널
1. 적절한 결과 타입을 담은 옵셔널을 반환한다.
2. 검사 예외를 전지는 대신에 빈 옵셔널울 반환한다.
->단점은 예외의 이유등 부가정보를 담을 수 없다.

### 검사 예외를 회피하는 방법 2: 메서드 분할
예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꾼다.

검사 예외를 던지는 메서드 - 리팩터링 전
```java
        try {
        obj.action(args);
        } catch (TheCheckedException e) {
        // 예외 복구
        }
```
상태 검사 메서드와 비검사 예외를 던지는 메서드 - 리팩터링 후
```java
        if(obj.actionPermitted(args)) {
        obj.action(args);
        } else {
        // 예외 복구
        }
```
이 방식이 모든 상황에 적용할 수는 없지만, 적용 할 수 있는 상황이라면 더 편리한 API를 제공할 수 있다.
리펙터링 후가 더 아름답진 않지만 유연하다.
-> 사용자가 실패시 스레드를 중단하기를 원한다면 obj.action(args) 한줄만 적어도 무방하다.

actionPermitted() 이 여러 스레드에서 동시에 접근된다면, 이 리팩터링은 적절치 않다.(아이템 69)
actionPermitted() 와 action() 사이에 객체 상태가 변할 수 있다.
actionPermitted() 와 action() 에 중복 수행이 있다면, 성능에서도 손해이기 때문에 리팩터링은 적절치 않을 수도 있다.


## 요약
1. 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 고통스러운 API를 낳는다.
2. 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.
3. 옵셔널만으로 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자
