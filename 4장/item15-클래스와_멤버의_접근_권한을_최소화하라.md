# 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

잘 설계된 컴포넌트는 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다. 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔하게 분리한다.

## 정보은닉(캡슐화)

### 장점
1. 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발 할 수 있기 때문

2. 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문

3. 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다. 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음(아이템67) 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문이다.

4. 소프트웨어 재사용성을 높인다. 외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트와 함께 개발되지 않는 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때문

5. 큰 시스템을 제작하는 난이도를 낮춰준다. 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문


### 접근 제어 메커니즘[JLS, 6.6]
클래스, 인터페이스, 멤버의 접근성(접근 허용 범위)을 명시한다.
정보 은닉의 핵심은  접근 제한자를 제대로 활용하는 것!

#### 기본 원칙
모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.
-> 소프트웨어가 올바르게 동작하는 한 항상 가장 낮은 접근 수준을 부여해야함

#### package-private(디폴트) VS public

공통점 :톱레벨(가장 바깥을 의미) 클래스와 인터페이스에 부여 가능한 접근 수준

차이점:
- package-private(디폴트) : 사용시 해당 패키지 내에서만 사용가능, 클라이언트에 피해 없이 다음 릴리스 수정/교체/제거 가능
- public : 사용시 공개 API가 됨, 하위 호환을 위해 영원히 관리해야함

한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스 안에 private static으로 중첩시켜보자.

```java
class DummyClass {
    private static class SomeClass {
        // SomeClass 내용
    }

    void useSomeClass() {
        SomeClass someClass = new SomeClass();
    }
}
```
DummyClass를 사용하는 바깥 클래스 하나에서만 useSomeClass를 통하여 SomeClass를 생성할 수 있다.

## 접근 수준

접근 범위가 좁은 순
- private : 멤버를 선언한 톱레벨 클래스에서만 접근
- package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근, 접근 제한자 명시하지 않으면 적용되는 접근 수준(단, 인터페이스의 멤버는 기본적으로 public)
- protected : package-private을 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근 가능
- public : 모든 곳에서 접근 가능

팁 :
- 공개 API를 세심히 설계 후, 그 외 모든 멤버는 private로 만들고 같은 패키지의 다른 클래스가 접근해야할때는 package-private로 풀어주자
- public클래스의 protected 멤버는 공개 API이므로 영원히 지원돼야 한다. 또한 내부 API 문서에 적어 사용자에 공개해야할 수도 있다. 따라서 적을수록 좋다.
- 단순 테스트용도의 멤버를 package-private수준까지 풀어줄 순 있지만 public으로 만들지 마라.(그렇게 해야 할 이유도 없다. 같은 패키지에서 테스트하기)

## public 클래스의 인스턴스 필드는 되도록 public이 아니어야한다.(아이템16)

final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다.
-> 그 필드와 관련된 모든것은 불변식을 보장할 수 없게 된다는 뜻

public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
-> 필드 수정 시 다른 작업을 할 수 없기 때문

예외적으로, 해당 클래스가 표현하는 추상 개념을 완성하는데 꼭 필요한 구성요소로써의 상수라면 public static final 필드로 공개해도 좋다.
-> 반드시 기본타입이나 불변객체를 참조해야 한다.(아이템17)

## 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.

클라이언트 레벨에서 배열의 내용을 수정할 수 있게 된다.

```java
//보안 허점이 숨어 있다.
public static final Thing[] VALUES = { ... } ;
```

### 해결책1

```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```
앞 코드의 public 배열을 private으로 만들고 public 불변 리스트를 추가하는 것이다.
* Collections.unmodifiableList: 메서드로 래핑한 리스트는 불변하므로, VALUES를 통해 리스트를 조회할 수 있지만 요소를 추가, 삭제 또는 변경할 수 없습니다.

### 해결책2

```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}
```
배열을 private으로 만들고 그 복사본을 반환하는 public 메서드를 추가하는 방법

둘 중 뭐가 나을지는 클라이언트가 무엇을 원하느냐에 따라 판단하여 사용하자.

## 자바9의 접근수준 추가

자바9에서부터 모듈 시스템 개념이 도입되면서 암묵적 접근 수준이 추가되었다.

모듈 시스템 : 패키지를 묶어 모듈화 시킨다.

- 패키지 중에 공개할 것들을 module-info.java에 exports로 설정한다. protected, public이라도 해당 패키지를 공개하지 않으면 모듈 외부에서 접근 불가능하다. 물론 모듈안에서는 공개 여부가 상관이 없다.

- jar 파일을 모듈 경로가 아닌 클래스패스에 두면 마치 모듈이 없는 것 처럼 행동한다.

모듈개념이 널리 받아들여질지 예측하기는 아직 이른 감이 있다. 그러니 꼭 필요한 경우가 아니라면 당분간은 사용하지 않는게 좋을 것 같다.

참고 : https://devyonghee.github.io/book/2022/07/24/modern-java-in-action-chapter14/

## 요약
1. 프로그램 요소의 접근성은 가능한 한 최소화 하라.
2. 의도치 않게 API로 공개되는 일이 없도록 해야한다.
3. public 클래스 내부에 public은 상수만 넣도록 한다.
4. 상수가 참조하는 객체가 불변인지 확인하라.